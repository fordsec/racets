\documentclass[review=true,acmlarge]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage[linguistics]{forest}
\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{xcolor}
\usepackage{mathpartir} % Inference rules
\usepackage[ruled]{algorithm2e} % For algorithms
\usepackage{setspace}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

% Metadata Information
%% \acmJournal{PACMHCI}
%% \acmVolume{9}
%% \acmNumber{4}
%% \acmArticle{39}
%% \acmYear{2010}
%% \acmMonth{3}
%% \acmArticleSeq{11}

%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}


% Copyright
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

% DOI
%\acmDOI{0000001.0000001}

% Paper history
%% \received{February 2007}
%% \received{March 2009}
%% \received[accepted]{June 2009}

\usepackage{amsmath}
\usepackage{listings}
\usepackage{racketlst}
\usepackage{xspace}
\lstset{language=Racket,xleftmargin=.1\textwidth,escapeinside={<@}{@>}}
\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

%% To color math, put it in an \mc command, e.g., \mc{$a$}
\newcommand{\colorMATH}{black!20!blue}
\newcommand{\colorID}{black!20!blue}
\newcommand{\colorCOMM}{0.133,0.545,0.133}
\newcommand{\colorFAC}{black!20!red}
\newcommand{\blue}[1] {{\color{\colorMATH} #1}}
\newcommand{\fcol}[1] {{\color{\colorFAC} #1}}
\newcommand{\bmth}[1] {{\color{\colorMATH} $#1$}}
\newcommand{\rmth}[1] {{\color{\colorFAC} $#1$}}
\newcommand{\code}[1]{\lstinline{#1}}

\newcommand{\comm}[3][\color{red}]{{#1{[{#2}: {#3}]}}}
\newcommand{\zw}[1]{\comm[\color{green!66!black}]{Zhanpeng}{#1}}
\newcommand{\kris}[1]{\comm[\color{blue}]{Kris}{#1}}
\newcommand{\tom}[1]{\comm[\color{orange}]{Tom}{#1}}
\newcommand{\lang}[0]{$\lambda_\textsc{FE}$\xspace}
\newcommand{\facet}[3]{{\fcol{\ensuremath{\langle \, {#1} \: ? \: {#2} \diamond \: {#3} \, \rangle}}}}
\newcommand{\formfacet}[3]{{\fcol{\ensuremath{\langle \langle \, {#1} \: ? \: {#2} \diamond \: {#3} \,  \rangle \rangle}}}}
\newcommand{\var}[1]{\mathit{#1}}

\begin{document}

\title{Racets: Policy{-}Agnostic Programming in Racket}

\author{Kristopher Micinski}
\affiliation{%
  \institution{Haverford College}
  \city{Haverford}
  \state{PA}
  \postcode{19041}
  \country{USA}}
\email{kris@cs.haverford.edu}
\author{Zhanpeng Wang}
\affiliation{%
  \institution{Haverford College}
  \city{Haverford}
  \state{PA}
  \postcode{19041}
  \country{USA}
}
\email{zwang10@haverford.edu}
\author{Thomas Gilray}
\affiliation{%
 \institution{University of Alabama}
 \city{Birmingham}
 \state{AL}
 \country{USA}}
\email{gilray@uab.edu}

\begin{abstract}lorem ipsum...\end{abstract}

%% \begin{CCSXML}
%% <ccs2012>
%%  <concept>
%%   <concept_id>10010520.10010553.10010562</concept_id>
%%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%%   <concept_significance>500</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>10010520.10010575.10010755</concept_id>
%%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%%   <concept_significance>300</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>10010520.10010553.10010554</concept_id>
%%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%%   <concept_significance>100</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>10003033.10003083.10003095</concept_id>
%%   <concept_desc>Networks~Network reliability</concept_desc>
%%   <concept_significance>100</concept_significance>
%%  </concept>
%% </ccs2012>
%% \end{CCSXML}

%% \ccsdesc[500]{Computer systems organization~Embedded systems}
%% \ccsdesc[300]{Computer systems organization~Redundancy}
%% \ccsdesc{Computer systems organization~Robotics}
%% \ccsdesc[100]{Networks~Network reliability}

\keywords{security, faceted execution, information flow, macros}

\maketitle

\renewcommand{\shortauthors}{Micinski, Wang, and Gilray}

\section{Introduction}

As our systems become more interconnected, they consume an
ever-growing amount of data.  System designers communicate to users
how their data is used via a \emph{privacy policy}. Unfortunately,
implementing these policies correctly is challenging: users often have
partial control over the policy (e.g., whether their phone number is
publicly visible or private) and policies change frequently (e.g.,
after new laws are passed). As policies evolve, developers face
massive (re)engineering efforts to ensure that implementations match
the espoused policy.

\emph{Policy-agnostic programming} is a linguistic paradigm that
decouples the implementation of privacy policies from the code that
operates on sensitive data. This frees developers to write programs as
they would normally, without inserting logic to manage the policy
directly into application code. Instead, data is labeled with its
policy as it enters the system, and propagates through the program as
computation progresses. Policy-agnostic programming is often
implemented using faceted execution, a dynamic information-flow
monitor encoding sensitive values as \emph{facets}: decision trees
specifying different views of that data. For example, the facet
\facet{Alice}{\code{#t}}{\code{#f}} represents a value that should
appear to Alice as \code{#t} and to everyone but Alice as \blue{\code{#f}}.

Faceted execution propagates facets by extending core linguistic
primitives (such as function application). For example, consider the
application \code{(not x)} where \code{x} is
\blue{\facet{Alice}{\code{#t}}{\code{#f}}}. The programmer intends the
call to \code{not} to be operating on a \code{boolean?}, but because
\code{x} is a facet this call produces \code{#f} instead. The correct
way to interpret function application on facets is to distribute the
application through each branch, producing \zw{producing ...?} %% \code{m
  %% \mc{ \facet{Alice}{\code{#f}}{\code{not #t}}}}
. Other core forms
(such as \code{if}, \code{cond}, etc...) require similar changes.

The core linguistic changes required by faceted execution have led to
relatively inelegant and heavyweight implementations thusfar. For
example, Flanagan et. al (who first presented faceted execution)
extended the JavaScript runtime to account for faceted
values. Similarly, the Jeeves programming language does (what does it
do?)\zw{Need to complete this sentence}. By contrast, Racket's 
highly-expressive macro system allows even
core forms (such as \code{#\%app}) to be redefined with relative ease.

In this paper we present Racets, an implementation of policy-agnostic
programming in Racket via macros. Racets provides facilities for
creating policies and faceting secure data with those policies. Racets
also extends several core forms in Racket to work with faceted
values (our implementation is detailed in Section~\ref{sec:implementation}). We
have measured the overhead of Racets in several microbenchmarks, and
have used Racets to implement a small server-based
board-game (detailed in Section~\ref{sec:evaluation}). We see Racets as a
promising prototype for policy-agnostic programming in Racket, and
conclude with several future directions in Section~\ref{sec:conclusion}.

\section{Overview of Faceted Execution}

To introduce our setting we present the implementation of Battleship,
a small guessing-based board game, in Racets (this section presents a
distilled version of our case study in
Section~\ref{sec:case-study}). In this game each player has a
grid-based board on which they place tiles (or ``ships''). The players
hide their boards from each other as play progresses in rounds. Each
turn a player guesses the position of a tile on the other player's
board. If the guess is successful that tile is removed from the
board. Play ends once one player's board has no remaining tiles, at
which point that player loses.

We implement game boards as lists of cons cells representing the
\blue{$(x,y)$} coordinates of ships. Board creation is simply the empty
list, and adding a piece is done via \lstinline|cons|:

\begin{lstlisting}[language=Racket,escapechar=|,name=example]
(define (makeboard) '())
(define (add-piece board x y) (cons (cons x y) board))
\end{lstlisting}

Next we define \code{mark-hit}, which takes a player's board and
removes a piece if the guessed coordinate is present. We 
return a pair of the updated board and a boolean indicating
whether the guess was a hit:

\begin{lstlisting}[language=Racket,escapechar=|,name=example]
(define (mark-hit board x y)
  (if (null? board)
      (cons board #f)
      (let* ([fst (car board)]
             [rst (cdr board)])
        (if (and (= (car fst) x)
                 (= (cdr fst) y))
            (cons rst #t)
            (let ([rst+b (mark-hit rst x y)])
              (cons (cons fst
                          (car rst+b))
                    (cdr rst+b)))))))
\end{lstlisting}

Although \code{mark-hit} will operate on sensitive data (the game
boards), it is written without any special machinery to maintain the
secrecy of \code{board}. Protecting data {w.r.t.} policies is instead handled
automatically and implicitly by a runtime monitor.
When Alice and Bob want to play a game, they both create a
\emph{label} to protect their data. A label is a predicate that takes
an argument and, if it returns true, reveals a secret. Alice's label
is used to annotate whatever data she wants to be kept
secret. Supposing Alice chooses to be player 1, she will use the
following label:

\begin{lstlisting}[language=Racket,escapechar=|,name=example]
(define alice-label (let-label l (lambda (x) (= 1 x))) l)
\end{lstlisting}

Bob would use a similar label (but with 2 instead of 1). At runtime,
the \code{label} form creates a label \blue{$\ell_{A}$} and returns it
to the binding for \code{alice-label}. When Alice wants to protect a
value, she creates a facet annotated with her label and two
\emph{branches}. The positive (left) branch represents the value as it
should appear to her, and the negative (right) to everyone else:

\begin{lstlisting}[language=Racket,escapechar=|,name=example]
  (define alice-board
          (facet alice-label (add-pieces (makeboard) x|$_1$| y|$_1$| |$...$|) star))
\end{lstlisting}

In the above example, Alice uses \blue{$\star$} (lazy failure) to
represent that others should see nothing if they observe the data. In
other applications, she might choose a more sensible default value to
reveal to others. She may even want to create a \emph{nested}
facet. For example, in a social-networking application she may want a
nested facet consisting of two labels for
\blue{$\ell_{\text{Friends}}$} and \blue{$\ell_{\text{Family}}$}. She
would present three views of her social-media profile: \bmth{p_1} to
her family, containing her phone number and other contact information,
\bmth{p_2} to her friends showing her interests, and \bmth{p_3} to
everyone else, showing only her name and email.

\begingroup
\begin{gather*}
\pgfkeys{/pgf/inner sep=0pt} \pgfkeys{/pgf/inner xsep=0pt}
  \begin{forest}
    l sep=0,s sep=1em,
    for children={l sep=0,s sep=1em},
    [\bmth{\ell_{\text{Family}}} [\bmth{p_1}] [\bmth{\ell_{\text{Friends}}} [\bmth{p_2}] [\bmth{p_3}]]]
  \end{forest}
\end{gather*}
\endgroup

As play of the game progresses, Alice and Bob both make guesses, and a
driver calls the function \code{mark-hit} with each of their (faceted)
game boards. However, because Alice and Bob's game boards are both
facets, \code{mark-hit} cannot be immediately applied, as the argument
\code{board} is a facet. Faceted execution ``splits'' the execution of
the function on faceted arguments, running it first on the positive
branch, then again on the negative branch. Finally, the results of
each branch are merged to produce a facet.

%% \begin{center}
%%   \begin{tikzpicture}
%% 	  \node (0) at (0, 1) {\lstinline|(mark-hit |{\color{\colorMATH}\(\facet{\ell_A}{v^+}{v^-} ~~ x ~~y\)}\lstinline|)|};
%% 	  \node (1) at (2, 0)  {\lstinline|(mark-hit |{\color{\colorMATH}\(v^- ~~ x ~~ y\)}\lstinline|)|{\color{\colorMATH}\(~~= v''\)}};
%% 	  \node (2) at (-2, 0) {\lstinline|(mark-hit |{\color{\colorMATH}\(v^+ ~~ x ~~ y\)}\lstinline|)|{\color{\colorMATH}\(~~= v'\)}};
%% 	  \node (3) at (0, -1) {{\color{\colorMATH}\(\facet{\ell_A}{v'}{v''}\)}};
%% 	  \draw [->] (0) edge (1);
%% 	  \draw [->] (0) edge (2);
%% 	  \draw [->] (1) edge (3);
%% 	  \draw [->] (2) edge (3);
%%   \end{tikzpicture}
%% \end{center}

Because the applied function can be stateful, faceted execution also
records the current privilege level in a \emph{program counter}. The
program counter is used to build facets when writes are made to the
store inside of a privileged context. We expand upon these subtleties
in Section~\ref{sec:semantics}, where we present a full semantics for
faceted execution.

\kris{Stuff about obs here..}

\section{A Formal Semantics for Faceted Execution}
\label{sec:semantics}

\begin{figure}
\begin{displaymath}
  \begin{array}{lcrcl}
    \blue{c} & \blue{\in} & \blue{const} & \blue{::=} & \blue{() \mid \code{\#t} \mid \code{\#f} \mid \ldots} \\
    \blue{x} & \blue{\in} & \blue{var} & \blue{::=} & \blue{\ldots}  \\
    \blue{e} & \blue{\in} & \blue{exp} & \blue{::=} & \blue{c} \mid \blue{x} \\
    & & & \blue{\mid} & \blue{(\lambda ~ (x) ~ e) \mid (e ~ e)} \\
    & & & \blue{\mid} & \blue{(\code{box} ~ e) \mid (\code{unbox} ~ e) \mid (\code{set!} ~ e ~ e)} \\
    & & & \blue{\mid} & \blue{(\code{let-label} ~ \ell ~ e ~ e)} \\
    & & & \blue{\mid} & \blue{(\code{facet} ~ e ~ e ~ e)} \\
    & & & \blue{\mid} & \blue{(\code{obs} ~ e ~ e ~ e)} \\
  \end{array}
\end{displaymath}
\label{fig:syntax}
\caption{Syntax of \lang}
\end{figure}

\begin{figure*}
    \begin{tabular}{cc}
      \begin{minipage}{.5\textwidth}
        \begin{displaymath}
          \begin{array}{rcrcl}
            \blue{\alpha} & \blue{\in} & \blue{\text{addr}} & \blue{=} & \blue{\ldots} \\
            \blue{bv} & \blue{\in} & \blue{\text{base-val}} & \blue{::=} & \blue{c \mid \alpha \mid \langle \lambda x.~ e, \rho \rangle \mid \star}\\
            \fcol{v} & \blue{\in} & \blue{\text{faceted-val}} & \blue{::=} & \blue{bv \mid} ~ \fcol{\facet{\blue{\alpha}}{v}{v}}
            \\
          \end{array}
        \end{displaymath}
      \end{minipage}
      &
      \begin{minipage}{.5\textwidth}
        \begin{displaymath}
          \begin{array}{rcrcl}
            \fcol{b} & \fcol{\in} & \fcol{\text{branch}} & \fcol{::=} & \fcol{+ \ell \mid - \ell} \\
            \fcol{pc} & \fcol{\in} & \fcol{\text{PC}} & \fcol{=} & \fcol{\wp(\text{branch})} \\
            \blue{\rho} & \blue{\in} & \blue{\text{env}} & \blue{=} & \blue{\text{var} \rightharpoonup v}\\
            \blue{\sigma} & \blue{\in} & \blue{\text{store}} & \blue{=} & \blue{\text{addr} \rightharpoonup v}
            \\
          \end{array}
        \end{displaymath}
      \end{minipage}
    \end{tabular}
    \\
    \hfill \textit{(Expression Evaluation)} \boxed{\blue{e, \rho, \sigma \Downarrow_{pc}^E \sigma, v}}
    \\
    \begin{displaymath}
      \begin{array}{c}
        \begingroup
        \color{\colorMATH}
        \begin{array}{cccc}
          \inferrule[\textsc{Const}]{ }
                                    {c, \rho, \sigma \Downarrow_{pc}^E \sigma, c}
                    & 
          \inferrule[\textsc{Var}]{ }
                                  {x, \rho, \sigma \Downarrow_{pc}^E \sigma, \rho(x)}
                    & 
          \inferrule[\textsc{Lambda}]{ }
                                     {\lambda x. ~ e, \rho, \sigma \Downarrow_{pc}^E \sigma, \langle \lambda x. ~ e, \rho \rangle}
                    &
          \inferrule[\textsc{Apply}]{e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', v_1 \and
                                     e_2, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v_2 \\\\
                                     \fcol{(v_1 ~ v_2), \rho, \sigma'' \Downarrow_{pc}^A \sigma''', v'}}
                                    {(e_1 ~ e_2), \rho, \sigma \Downarrow_{pc}^E \sigma''', v'}
        \end{array}
       \endgroup
        \\\\
        \begingroup
        \color{\colorMATH}
        \begin{array}{ccc}
          \inferrule[\textsc{Box}]
                    {e, \rho, \sigma \Downarrow_{pc}^E \sigma', v \and
                      \alpha \not\in dom(\sigma') \\\\
                      \sigma'' = \sigma' [\alpha \mapsto \formfacet{pc}{v}{\star}]}
                    {(\code{box} ~ e), \rho, \sigma \Downarrow_{pc}^E \sigma'', \alpha}
                    & 
          \inferrule[\textsc{Unbox}]
                    {e, \rho, \sigma \Downarrow_{pc}^E \sigma', v \\\\
                     v' = \fcol{\var{read}(\sigma',v,pc)}}
                    {(\code{unbox} ~e), \rho, \sigma \Downarrow_{pc}^E \sigma', v'}
                    & 
          \inferrule[\textsc{Set}]
                    {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', v_1 \and
                     e_2, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v_2 \\\\
                     \sigma''' = \fcol{\var{write}(\sigma'', v_1, pc, v_2)}}
                    {(\code{set!} ~ e_1 ~ e_2), \rho, \sigma \Downarrow_{pc}^E \sigma''', v_2}
        \end{array}
       \endgroup
       \\\\
       \hfill \textit{(Facet Creation)}
       \\
       \begin{array}{ccc}
          {\color{\colorFAC}
          \inferrule[\textsc{Fac-Create-Split}]
          {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
            \{+\ell, -\ell\} \cap pc = \varnothing \\\\
           e_2, \rho, \sigma' \Downarrow_{pc \cup \{+l\}}^E \sigma'', v_1 \\\\
           e_3, \rho, \sigma'' \Downarrow_{pc \cup \{-l\}}^E \sigma''', v_2 \and
           v = \formfacet{pc}{v_1}{v_2}}
          {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma''', v}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{Fac-Create-Pos}]
          {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
           + \ell \in pc \\\\
           e_2, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v}
          {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'', v}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{Fac-Create-Neg}]
          {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
           - \ell \in pc \\\\
           e_3, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v}
          {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'', v}}     \end{array}

      \end{array}
    \end{displaymath}
    \\
    \hfill \textit{(Label Creation / Observation)}
    \\
    \[
    \begin{array}{cc}
      {\color{\colorFAC}
        \inferrule[\textsc{Let-Label}]
          {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \langle \lambda x. ~ e, \rho' \rangle \\\\
           \alpha \not\in dom(\sigma') \and \sigma'' = \sigma' [\alpha \mapsto \langle \lambda x. ~ e, \rho' \rangle] \\\\
           e_2, \rho [ \ell \mapsto \alpha ], \sigma'' \Downarrow_{pc}^E \sigma''', v}
          {(\code{let-label} ~ \ell ~ e_1 ~ e_2), \rho, \sigma \Downarrow_{pc}^E \sigma''', v}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{Obs}]
                    {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell
                      \and e_2, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v  \\\\
                      \langle (\lambda x.~e), \rho' \rangle = \sigma''(\ell) \\\\
                      e, \rho' [x \mapsto v], \sigma'' \Downarrow_{pc}^E \sigma''', v^{\pm} \\\\
                      e_3, \rho, \sigma''' \Downarrow_{pc}^E \sigma'''', v' \\\\
                      v'' = \fcol{\var{obs}(\ell, v', v^{\pm})}}
                    {(\code{obs} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'''', v''}}
    \end{array}
    \]
    \\
    \hfill \textit{(Possibly-Faceted Application)} \boxed{\fcol{(v_1 ~ v_2), \rho, \sigma \Downarrow_{pc}^A \sigma, v}}
    \\
    \begingroup
    \color{\colorMATH}
    \begin{displaymath}
      \begin{array}{c}
        \begin{array}{ccc}
          {\color{\colorMATH}
          \inferrule[\textsc{App-$\star$}]
          { }
          {(\star ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma, \star}}
          & 
          {\color{\colorMATH}
          \inferrule[\textsc{App-Base}]
          {e, \rho'[x \mapsto v], \sigma \Downarrow_{pc}^E \sigma', v' }
          {(\langle \lambda x.~e, \rho' \rangle ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{App-Split}]
          {\{+\ell, -\ell\} \cap pc = \varnothing \and
            (v^+ ~ v), \rho, \sigma \Downarrow_{pc \cup \{+\ell\}}^A \sigma', {v^+}' \\\\
            (v^- ~ v), \rho, \sigma' \Downarrow_{pc \cup \{-\ell\}}^A \sigma'', {v^-}' \and
            v' = \formfacet{\{+ \ell\}}{{v^+}'}{{v^-}'}}
          {(\facet{\ell}{v^+}{v^-} ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma'', v'}}
        \end{array}
        \\
        \begin{array}{cc}
        \\\\
          {\color{\colorFAC}
          \inferrule[\textsc{App-Facet-Pos}]
          {+\ell \in pc \\\\
            (v^+ ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}
          {(\facet{\ell}{v^+}{v^-} ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{App-Facet-Neg}]
          {-\ell \in pc \\\\
            (v^- ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}
          {(\facet{\ell}{v^+}{v^-} ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}}
        \end{array}
      \end{array}
    \end{displaymath}
    \endgroup
    \caption{Semantics of Faceted Execution}
    \label{fig:semantics}
\end{figure*}

We now present a semantics for a core language (\lang) which includes
facets. Our presentation largely mirrors that of Austin et
al.~\cite{Austin:2013}. The syntax of our language---reminiscent of
Scheme---is shown in Figure~\ref{fig:syntax}. \lang extends the lambda
calculus with references (which have interactions with facets in a subtle
way) and three forms unique to faceted execution: facet construction, 
label creation, and facet observation.

Our semantics is shown in Figure~\ref{fig:semantics}. As \lang is an
extension of the lambda calculus with references, we present the parts
unique to faceted execution in \fcol{red}, while keeping the lambda
calculus with references in \blue{blue}. Base values in our semantics
include addresses (used for boxes), constants, and closures. We also
include a kind of lazy failure (\bmth{\star}), which is necessary for
defining store update within a protected context.

Values in our semantics are either (unfaceted) base values or facets
composed of a label and two branches. Facets can nest, allowing trees
of faceted values. We use the term \emph{branches} to refer to
positive or negated labels. Collections of branches define the program
counter \rmth{pc}, which tracks the set of branches in the current
context. For example, to apply a faceted function to a value (as in
the application of \bmth{\facet{\ell}{\lambda x.~0}{\lambda x.~1}}),
the semantics first applies \bmth{\lambda x.~0} while extending \rmth{pc}
with \rmth{+\ell}, then applies the negative branch extending
\rmth{pc} with \rmth{-\ell}.

The reduction relation \bmth{e, \rho, \sigma \Downarrow_{pc}^E \sigma,
  v} reduces an expression, environment, and store to a resulting
store and value. The first three rules (all in blue) are unchanged
from the standard interpretation in the lambda calculus. The
\textsc{Apply} rule calls out to the helper relation \rmth{(v~v),
  \rho, \sigma \Downarrow_{pc}^A \sigma, v}, which applies a
possibly-faceted value to an argument: if the value being applied is a
plain (unfaceted) closure, the \textsc{App-Base} rule (in blue, as it
is unchanged from the lambda calculus) applies it and returns
immediately to the \bmth{\Downarrow_{pc}^E} relation.

In the case that a faceted value is applied, \rmth{\Downarrow_{pc}^A}
performs one of three functions, based on the relation of \rmth{\ell}
to \rmth{pc}. If there is no occurrence of either \rmth{+\ell} or
\rmth{-\ell} in \rmth{pc}, then the semantics has not yet branched on
\rmth{\ell}, and therefore must split the application. To do this, it
applies both the positive and negative branches after extending
\rmth{pc}. After reducing both branches to values, the results are
formed into a facet. If \rmth{+\ell \in pc}, then the semantics has
already branched on the label \rmth{\ell}, so splitting would be
redundant. In this case, \rmth{\Downarrow_{pc}^A} simply selects the
positive branch to apply and continues without splitting. The
symmetric case occurs in \textsc{App-Facet-Neg}. Facet formation
follows this pattern, accounting for the relation of \rmth{\ell} to
\rmth{pc}.

The rules \textsc{Box}, \textsc{Unbox}, and \textsc{Set} appear
similar to the standard implementation of boxes, but employ several
meta-functions to do their work. This is because box creation, reads,
and writes may occur within a privilaged context, and care must be
taken to form facets when \rmth{pc} is nonempty. To understand why,
consider the following example\footnote{Our formal semantics elides
  \code{if}, though it may be obtained via a Church encoding if
  desired as in Austin et al.\cite{Austin:12}. Our implementation
  includes \code{if} but not other constructs such as \code{cond}}:

\begin{lstlisting}[language=Racket,escapechar=|,name=boxexample]
(define x (box 0))
(if (= (facet alice 0 1) 0)
  (set! x 0)
  (set! x 1))
(unbox x)
\end{lstlisting}

If we do nothing special to account for the fact that the program
branches on the facet, control flow implicitly launders the value
through the box to an unfaceted value. To fix this, we form a facet by
taking into account \rmth{pc} and forming a facet using the
meta-function \rmth{\formfacet{\ell}{v^+}{v^d}}. This meta-function is
defined in Figure~\ref{fig:metafunctions}, and takes three arguments:
the current \rmth{pc}, a positive view (\rmth{v^+}), and a ``default''
view (\rmth{v^d}). Facet construction builds a facet with a spine
corresponding to all of the labels in \rmth{pc}, and inserts
\rmth{v^+} at the focus corresponding to \rmth{pc}, putting the
default value \rmth{v^d} along all other branches. In the \code{box}
form, the facet uses a default value of \bmth{\star}. In terms of our
above example, this means that along the positive branch \code{x}
would be set to \facet{\code{alice}}{1}{\star} (as the false branch of
the \code{if} is taken), and along the subsequent negative branch
\code{x} is extended to \facet{\code{alice}}{1}{0}.

\begin{figure*}
      %\begin{displaymath}
      %  \begin{array}{rclrr}
      %    {read(\sigma, \alpha, pc)} & {=} & {\sigma(\alpha)} & & \\
      %    {read(\sigma, \facet{\ell}{v_1}{v_2}), pc} & = & {read(\sigma, v_1, pc)} & \textit{if} ~ {+\ell} \in pc & \\
      %    {read(\sigma, \facet{\ell}{v_1}{v_2}), pc} & = & {read(\sigma, v_2, pc)} & \textit{if} ~ {-\ell} \in pc & \\
      %    {read(\sigma, \facet{\ell}{v_1}{v_2}), pc} & = & {\formfacet{\ell}{read(\sigma, v_1, pc)}{read(\sigma, v_2, pc)}} & \textit{otherwise} &
       % \end{array}
      %\end{displaymath}
      \begin{displaymath}
        \begin{array}{rclrr}
          {\formfacet{\varnothing}{v_1}{v_2}} & {=} & {v_1} \\
          {\formfacet{\{+\ell\} \cup rest}{v_1}{v_2}} & {=} & {\facet{\ell}{\formfacet{rest}{v_1}{v_2}}{v_2}} \\
          {\formfacet{\{-\ell\} \cup rest}{v_1}{v_2}} & {=} & {\facet{\ell}{v_2}{\formfacet{rest}{v_1}{v_2}}}
        \end{array}
      \end{displaymath}
      \\
      \begin{displaymath}
        \begin{array}{rclrr}
          {\var{write}(\sigma, \alpha, pc, v)} & {=} & {\sigma[\alpha ~ := \formfacet{pc}{v}{\sigma(\alpha)}]} & & \\
          {\var{write}(\sigma, \facet{\ell}{v_1}{v_2}), pc, v} & = & {\sigma''} & \textit{where} ~ {\sigma' = \var{write}(\sigma, v_1, pc \cup \{+\ell\}, v)} \\
          & & & \textit{and} ~ {\sigma'' = \var{write}(\sigma', v_2, pc \cup \{-\ell\}, v)}
        \end{array}
      \end{displaymath}
      %\\
      %\begin{displaymath}
      %  \begin{array}{rclrr}
      %    {obs(\ell, b, bv)} & {=} & {bv} & & \\
      %    {obs(\ell, true,} \facet{\ell}{v_1}{v_2}) & = & {v_1} & & \\
      %    {obs(\ell, false,} \facet{\ell}{v_1}{v_2}) & = & {v_2} & & \\
      %    {obs(\ell, b,} \facet{\ell'}{v_1}{v_2}) & = & \facet{\ell'}{obs(\ell,b,v_1)}{obs(\ell,b,v_2)} & \textit{where} & {\ell} \neq {\ell'}
      %  \end{array}
      %\end{displaymath}
      \caption{Meta-functions used in our semantics}
      \label{fig:metafunctions}
\end{figure*}

Label creation allocates a label as a fresh address in the store,
binding the specified label predicate and adding it to the
environment. Labels must be store-allocated rather than bound in the
lexical environment, as the latter would allow the label to be rebound
by anyone using the facet:

\begin{lstlisting}[language=Racket,escapechar=|,name=rebindingexample]
(define alice-label (let-label l (lambda (x) (= x alice)) l))
(define x (fac alice-label 1 0))
(let ([alice-label (let-label l (lambda (x) #t) l)]) |\label{lineno:alicelab}|
  (obs alice-label 1 x)) ; Should return |\facet{\texttt{alice-label}}{1}{0}|
\end{lstlisting}

The \code{obs} form in the above example ought to return
\facet{\code{alice-label}}{1}{0}. But if we pull labels from the
lexical environment, the binding on line~\ref{lineno:alicelab} shadows
the policy originally associated with the facet.

Last, observation evaluates the label expression to an address and
executes the associated predicate. Once this is done, \textsc{Obs}
uses the \rmth{\var{obs}} meta-function to select the appropriate
branch based on the value returned by the predicate associated with
the label. This meta-function accounts for the fact that the label
being observed may appear arbitrarily deep in the facet (or not at
all).

\section{Faceted Execution as Macros}

The semantics of faceted execution is an extension of the lambda
calculus, leading to a natural question: can we use Racket's macros to
extend Racket to faceted execution? We will see that the answer is
yes, and the translation from the big-step rules is surprisingly
straightforward. This section of our paper describes the design of
Racets, a prototype implementation of faceted execution using Racket
macros. In Section~\ref{sec:conclusion} we remark upon current
directions scaling Racets to the whole of Racket.

\paragraph*{Choosing a Representation for Facets, Labels, and Program Counters}

In setting out to implement facets, we must first choose how we will
represent facets, labels, and program counters. We have chosen to
implement facets simply as Racket \lstinline|struct|s, containing a
label along with positive and negative branches:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(struct facet (labelname left right))
\end{lstlisting}

Next, we must choose a representation of labels. At first
consideration, it appears sensible to represent labels simply as
closures. After all, labels are simply used as predicates testing
whether or not to reveal a facet's positive or negative
branch. Therefore, we represent labels as a pair of a name and a policy:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(struct labelpair (name pol))
\end{lstlisting}

Now that we have defined labels, we can define branches, which are
positive or negative labels:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(struct pos (lab))
(struct neg (lab))
\end{lstlisting}

Similarly, program counters are sets of branches. However, we must
still ask how we will keep track of the ``current'' program
counter. Our implementation uses Racket's parameters, though other
mechanisms (such as continuation marks\kris{cite}, to which parameters
macro-expand) could also be used. Racets defines the parameter
\code{current-pc}, and updates it as computation progresses:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(define current-pc (make-parameter (set)))
\end{lstlisting}

\paragraph*{Facet Creation}

Facet creation appears as three separate rules in
Figure~\ref{fig:semantics}, which we recapitulate here in three
distint colors for each case:

\[\small
\begin{array}{ccc}
  {\color{brown}
    \inferrule[\textsc{Fac-Create-Pos}]
              {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
                \boxed{+ \ell \in pc} \\\\
                e_2, \rho, \sigma \Downarrow_{pc}^E \sigma'', v}
              {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'', v}}
  & 
  {\color{gray}
    \inferrule[\textsc{Fac-Create-Neg}]
              {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
                \boxed{- \ell \in pc} \\\\
                e_3, \rho, \sigma \Downarrow_{pc}^E \sigma'', v}
              {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'', v}}
  &
  {\color{purple}
    \inferrule[\textsc{Fac-Create-Split}]
              {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
                \boxed{\{+\ell, -\ell\} \cap pc = \varnothing} \\\\
                e_2, \rho, \sigma' \Downarrow_{pc \cup \{+l\}}^E \sigma'', v_1 \\\\
                e_3, \rho, \sigma'' \Downarrow_{pc \cup \{-l\}}^E \sigma''', v_2 \and
                v = \formfacet{pc}{v_1}{v_2}}
              {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma''', v}}


\end{array}
\]

Translating these rules to Racket involves observing that each one
will apply under one of three disjoint circumstances (each of them
boxed in the above rules): \bmth{+\ell \in pc}, \bmth{-\ell \in pc},
or else \bmth{\{+\ell,-\ell\} \cap pc = \varnothing}. This is a common
idiom in our faceted semantics, as we often want to select the
appropriate branch of a facet if its label already exists in
\bmth{pc}.

At first glance, it may not be obvious that we even \emph{need} a macro
for facet creation. But according to our semantics, the following
snippet should produce \code{#t} if \bmth{+\ell \in pc}:

\begin{lstlisting}[language=Racket,escapeinside={<@}{@>},name=other,numbers=none]
(fac l #t (error ''this shouldn't get evaluated if <@\bmth{+\ell \in pc}@>''))
\end{lstlisting}

If we were to implement \code{fac} as a function, it would force
evaluation of the negative branch, inconsistent with the semantics of
\textsc{Fac-Create-Pos}. We can implement each of these conditions as
a Racket macro by considering whether \bmth{\ell \in pc}, as shown in
Figure~\ref{fig:fac-create}. Each color in the listing corresponds to
the analogous semantic rule. The implementation of
\textsc{Fac-Create-Pos} and \textsc{Fac-Create-Neg} is relatively
straightforward, but \textsc{Fac-Create-Split} extends \bmth{pc} for
each branch and subsequently forms a facet. This function implements
canonicalizing facet construction, and (as the implementation is a
transliteration of that in Figure 6 of Austin et
al.~\cite{Austin:2012}) we omit its definition here.

\begin{figure}
{\small
\begin{lstlisting}[language=Racket,escapeinside={<@}{@>},name=racets]
(define-syntax-rule (fac l e1 e2)
  (cond
\end{lstlisting}
\vspace{-.7\baselineskip}
{\color{brown}
\begin{lstlisting}[language=Racket,escapeinside={<@}{@>},name=racets,identifierstyle=\color{brown}]
    [(set-member? (current-pc) (pos (facet-labelname l))) e1]
\end{lstlisting}
}
\vspace{-.7\baselineskip}
{\color{gray}
\begin{lstlisting}[language=Racket,escapeinside={<@}{@>},name=racets,identifierstyle=\color{gray}]
    [(set-member? (current-pc) (neg (facet-labelname l))) e2]
\end{lstlisting}
}
\vspace{-.7\baselineskip}
{\small\color{purple}
\begin{lstlisting}[language=Racket,escapeinside={<@}{@>},name=racets,identifierstyle=\color{purple},keywordstyle=\color{purple}]
    [else
     (let ([left (parameterize
                     ([current-pc (set-add (current-pc)
                                           (pos (facet-labelname l)))]))]
           [right (parameterize
                      ([current-pc (set-add (current-pc)
                                            (neg (facet-labelname l)))]))]
           (mkfacet (labelpair-name l) v1 v2)))]))
\end{lstlisting}}
}
\caption{Facet creation as a macro}
\label{fig:fac-create}
\end{figure}

\paragraph*{Label Creation}

As we chose a representation of labels as pairs of symbols (the
label's name) and closures (the predicate corresponding to the label),
label creation is relatively straightforward from the semantics:

\begin{lstlisting}[language=Racket,escapeinside={<@}{@>},name=racets]
(define-syntax-rule (let-label l (lambda xs e) body)
  (let ([l (labelpair (gensym 'lab)
                      (lambda xs e))])
    body))
\end{lstlisting}

\paragraph*{Faceted Boxes, Writes, and Observations}

Our faceted semantics includes explicit \code{box} and \code{unbox}
forms. This differs from Racket's semantics, where any variable may be
treated as a box due to assignment conversion. We have two main
options:

\begin{itemize}
\item Introduce an explicit \code{unbox} form in Racets, trusting the
  programmer to explicitly use our implementation of \code{unbox} on
  potentially-faceted objects.

\item Walk over Racket code (after macro-expansion via
  \code{local-expand}) transforming variable references to use
  explicit \code{unbox} forms from Racets.
\end{itemize}

For our prototype of Racets, we have chosen to implement the
first. This leads to a relatively simple implementation, but
essentially trusts the programmer to use Racets' \code{unbox} forms
when necessary.


\begin{figure}
\small
\begin{lstlisting}[language=Racket,escapeinside={<@}{@>},name=racets]
(define-syntax (ref-set! stx)
  (syntax-case stx ()
    [(_ var e)
     #`(let ([v e])
         (let write ([var var]
                     [pc (current-pc)])
           (if (box? var)
               ; <@$\color[rgb]{\colorCOMM}\var{write}(\sigma, \alpha, pc, v)$@>
               (set-box! var (construct-facet (current-pc) v (unbox var)))
               ; Else split
               (mkfacet
                 (facet-labelname (unbox var))
                 ; <@$\color[rgb]{\colorCOMM}\var{write}(\sigma, \alpha, pc \cup \{+l\}, v)$@>
                 (write
                   (facet-left (unbox var))
                   (set-add pc (pos (facet-labelname var))))
                 ; <@$\color[rgb]{\colorCOMM}\var{write}(\sigma, \alpha, pc \cup \{-l\}, v)$@>
                 (write
                   (facet-right (unbox var))
                   (set-add pc (neg (facet-labelname var))))))))]))
\end{lstlisting}
\caption{Racets' implementation of \code{set!}}
\label{fig:setbang}
\end{figure}

Racets defines a \code{box} macro, along with \code{unbox} and
\code{set!}. We include the definition of \code{set!} in
Figure~\ref{fig:setbang}, which inlines the definition of the
\textit{write} metafunction from Section~\ref{sec:semantics} to
consider the case under which a facet is used when an address is
expected.

Facet observation is handled similarly, first evaluating the label to
produce a policy predicate, followed by evaluating the policy's
argument and a possibly-faceted value to observe. After applying the
policy its argument, we produce the value \bmth{v^{\pm}} and descend
down the facet until reaching either a base value or finding the
selected label (at which point we select the appropriate branch).

\paragraph*{Faceted Function Application}

By now we can anticipate a predictable pattern for implementing
faceted execution: check \bmth{pc} to decide whether to branch left,
right, or split. This is largely our strategy for handling faceted
function application, with a small twist: we need to be able to apply
functions from outside of Racets. For example, if we want to apply
builtin functions such as \code{display}, we need to be mindful of the
fact that these functions cannot work with faceted arguments.

To handle this, we implement a macro for the \code{lambda} form, to
tag Racet closures specifically (so that they are differentiated from
functions outside of the current module). In the case that a foreign
function is applied to a faceted value, our implementation of function
application wraps the function to be able to handle facets by
distributing the function through each branch of the facet.

In general it is unsafe to apply an unknown function to a faceted
value. This is because the unknown function may leak the facet's
private information as a side-effect. Therefore, our current
implementation of Racets allows programmers to apply external
functions, but does not make any guarantee of safety. A better
strategy may be to perform an \code{obs} before each call to a
potentially-unsafe function. In general, we believe module
interactions are a challenging problem in faceted execution, and we
leave its study to future work.

\section{Implementation and Evaluation}

\section{Conclusion}

\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}
\end{document}


