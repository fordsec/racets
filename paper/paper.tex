\documentclass[review=true,acmlarge]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage[linguistics]{forest}
\usepackage{tikz}
\usetikzlibrary{cd}
\usepackage{xcolor}
\usepackage{mathpartir} % Inference rules
\usepackage[ruled]{algorithm2e} % For algorithms
\usepackage{setspace}
\renewcommand{\algorithmcfname}{ALGORITHM}
\SetAlFnt{\small}
\SetAlCapFnt{\small}
\SetAlCapNameFnt{\small}
\SetAlCapHSkip{0pt}
\IncMargin{-\parindent}

% Metadata Information
%% \acmJournal{PACMHCI}
%% \acmVolume{9}
%% \acmNumber{4}
%% \acmArticle{39}
%% \acmYear{2010}
%% \acmMonth{3}
%% \acmArticleSeq{11}

%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}


% Copyright
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

% DOI
%\acmDOI{0000001.0000001}

% Paper history
%% \received{February 2007}
%% \received{March 2009}
%% \received[accepted]{June 2009}

\usepackage{amsmath}
\usepackage{listings}
\usepackage{racketlst}
\usepackage{xspace}
\lstset{basicstyle=\ttfamily,language=Racket,xleftmargin=.1\textwidth}
\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

%% To color math, put it in an \mc command, e.g., \mc{$a$}
\newcommand{\colorMATH}{black!20!blue}
\newcommand{\colorFAC}{black!20!red}
\newcommand{\blue}[1] {{\color{\colorMATH} #1}}
\newcommand{\fcol}[1] {{\color{\colorFAC} #1}}
\newcommand{\bmth}[1] {{\color{\colorMATH} $#1$}}
\newcommand{\code}[1]{\lstinline{#1}}

\newcommand{\comm}[3][\color{red}]{{#1{[{#2}: {#3}]}}}
\newcommand{\zw}[1]{\comm[\color{green!66!black}]{Zhanpeng}{#1}}
\newcommand{\kris}[1]{\comm[\color{blue}]{Kris}{#1}}
\newcommand{\tom}[1]{\comm[\color{orange}]{Tom}{#1}}
\newcommand{\lang}[0]{$\lambda_\textsc{FE}$\xspace}
\newcommand{\facet}[3]{{\fcol{\ensuremath{\langle \, {#1} \: ? \: {#2} \diamond \: {#3} \, \rangle}}}}
\newcommand{\formfacet}[3]{{\fcol{\ensuremath{\langle \langle \, {#1} \: ? \: {#2} \diamond \: {#3} \,  \rangle \rangle}}}}
\newcommand{\var}[1]{\mathit{#1}}

\begin{document}

\title{Racets: Embedding Policy{-}Agnostic Programming in Racket}

\author{Kristopher Micinski}
\affiliation{%
  \institution{Haverford College}
  \city{Haverford}
  \state{PA}
  \postcode{19041}
  \country{USA}}
\email{kris@cs.haverford.edu}
\author{Zhanpeng Wang}
\affiliation{%
  \institution{Haverford College}
  \city{Haverford}
  \state{PA}
  \postcode{19041}
  \country{USA}
}
\email{zwang10@haverford.edu}
\author{Thomas Gilray}
\affiliation{%
 \institution{University of Alabama}
 \city{Birmingham}
 \state{AL}
 \country{USA}}
\email{gilray@uab.edu}

\begin{abstract}lorem ipsum...\end{abstract}

%% \begin{CCSXML}
%% <ccs2012>
%%  <concept>
%%   <concept_id>10010520.10010553.10010562</concept_id>
%%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%%   <concept_significance>500</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>10010520.10010575.10010755</concept_id>
%%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%%   <concept_significance>300</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>10010520.10010553.10010554</concept_id>
%%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%%   <concept_significance>100</concept_significance>
%%  </concept>
%%  <concept>
%%   <concept_id>10003033.10003083.10003095</concept_id>
%%   <concept_desc>Networks~Network reliability</concept_desc>
%%   <concept_significance>100</concept_significance>
%%  </concept>
%% </ccs2012>
%% \end{CCSXML}

%% \ccsdesc[500]{Computer systems organization~Embedded systems}
%% \ccsdesc[300]{Computer systems organization~Redundancy}
%% \ccsdesc{Computer systems organization~Robotics}
%% \ccsdesc[100]{Networks~Network reliability}

\keywords{security, faceted execution, information flow, macros}

\maketitle

\renewcommand{\shortauthors}{Micinski, Wang, and Gilray}

\section{Introduction}

As our systems become more interconnected, they consume an
ever-growing amount of data.  System designers communicate to users
how their data is used via a \emph{privacy policy}. Unfortunately,
implementing these policies correctly is challenging: users often have
partial control over the policy (e.g., whether their phone number is
publicly visible or private) and policies change frequently (e.g.,
after new laws are passed). As policies evolve, developers face
massive (re)engineering efforts to ensure that implementations match
the espoused policy.

\emph{Policy-agnostic programming} is a linguistic paradigm that
decouples the implementation of privacy policies from the code that
operates on sensitive data. This frees developers to write programs as
they would normally, without inserting logic to manage the policy
directly into application code. Instead, data is labeled with its
policy as it enters the system, and propagates through the program as
computation progresses. Policy-agnostic programming is often
implemented using faceted execution, a dynamic information-flow
monitor encoding sensitive values as \emph{facets}: decision trees
specifying different views of that data. For example, the facet
\facet{Alice}{\code{#t}}{\code{#f}} represents a value that should
appear to Alice as \code{#t} and to everyone but Alice as \blue{\code{#f}}.

Faceted execution propagates facets by extending core linguistic
primitives (such as function application). For example, consider the
application \code{(not x)} where \code{x} is
\blue{\facet{Alice}{\code{#t}}{\code{#f}}}. The programmer intends the
call to \code{not} to be operating on a \code{boolean?}, but because
\code{x} is a facet this call produces \code{#f} instead. The correct
way to interpret function application on facets is to distribute the
application through each branch, producing %% \code{m
  %% \mc{ \facet{Alice}{\code{#f}}{\code{not #t}}}}
. Other core forms
(such as \code{if}, \code{cond}, etc...) require similar changes.

The core linguistic changes required by faceted execution have led to
relatively inelegant and heavyweight implementations thusfar. For
example, Flanagan et. al (who first presented faceted execution)
extended the JavaScript runtime to account for faceted
values. Similarly, the Jeeves programming language does (what does it
do?). By contrast, Racket's highly-expressive macro system allows even
core forms (such as \code{#\%app}) to be redefined with relative ease.

In this paper we present Racets, an implementation of policy-agnostic
programming in Racket via macros. Racets provides facilities for
creating policies and faceting secure data with those policies. Racets
also extends several core forms in Racket to work with faceted
values (our implementation is detailed in Section~\ref{sec:implementation}). We
have measured the overhead of Racets in several microbenchmarks, and
have used Racets to implement a small server-based
board-game (detailed in Section~\ref{sec:evaluation}). We see Racets as a
promising prototype for policy-agnostic programming in Racket, and
conclude with several future directions in Section~\ref{sec:conclusion}.

\section{Overview of Faceted Execution}

To introduce our setting we present the implementation of Battleship,
a small guessing-based board game, in Racets (this section presents a
distilled version of our case study in
Section~\ref{sec:case-study}). In this game each player has a
grid-based board on which they place tiles (or ``ships''). The players
hide their boards from each other as play progresses in rounds. Each
turn a player guesses the position of a tile on the other player's
board. If the guess is successful that tile is removed from the
board. Play ends once one player's board has no remaining tiles, at
which point that player loses.

We implement game boards as lists of cons cells representing the
\blue{$(x,y)$} coordinates of ships. Board creation is simply the empty
list, and adding a piece is done via \lstinline|cons|:

\begin{lstlisting}[language=Racket,escapechar=|,name=example]
(define (makeboard) '())
(define (add-piece board x y) (cons (cons x y) board))
\end{lstlisting}

Next we define \code{mark-hit}, which takes a player's board and
removes a piece if the guessed coordinate is present. We 
return a pair of the updated board and a boolean indicating
whether the guess was a hit:

\begin{lstlisting}[language=Racket,escapechar=|,name=example]
(define (mark-hit board x y)
  (if (null? board)
      (cons board #f)
      (let* ([fst (car board)]
             [rst (cdr board)])
        (if (and (= (car fst) x)
                 (= (cdr fst) y))
            (cons rst #t)
            (let ([rst+b (mark-hit rst x y)])
              (cons (cons fst
                          (car rst+b))
                    (cdr rst+b)))))))
\end{lstlisting}

Although \code{mark-hit} will operate on sensitive data (the game
boards), it is written without any special machinery to maintain the
secrecy of \code{board}. Protecting data {w.r.t.} policies is instead handled
automatically and implicitly by a runtime monitor.
When Alice and Bob want to play a game, they both create a
\emph{label} to protect their data. A label is a predicate that takes
an argument and, if it returns true, reveals a secret. Alice's label
is used to annotate whatever data she wants to be kept
secret. Supposing Alice chooses to be player 1, she will use the
following label:

\begin{lstlisting}[language=Racket,escapechar=|,name=example]
(define alice-label (let-label l (lambda (x) (= 1 x))) l)
\end{lstlisting}

Bob would use a similar label (but with 2 instead of 1). At runtime,
the \code{label} form creates a label \blue{$\ell_{A}$} and returns it
to the binding for \code{alice-label}. When Alice wants to protect a
value, she creates a facet annotated with her label and two
\emph{branches}. The positive (left) branch represents the value as it
should appear to her, and the negative (right) to everyone else:

\begin{lstlisting}[language=Racket,escapechar=|,name=example]
  (define alice-board
          (facet alice-label (add-pieces (makeboard) x|$_1$| y|$_1$| |$...$|) star))
\end{lstlisting}

In the above example, Alice uses \blue{$\star$} (lazy failure) to
represent that others should see nothing if they observe the data. In
other applications, she might choose a more sensible default value to
reveal to others. She may even want to create a \emph{nested}
facet. For example, in a social-networking application she may want a
nested facet consisting of two labels for
\blue{$\ell_{\text{Friends}}$} and \blue{$\ell_{\text{Family}}$}. She
would present three views of her social-media profile: \bmth{p_1} to
her family, containing her phone number and other contact information,
\bmth{p_2} to her friends showing her interests, and \bmth{p_3} to
everyone else, showing only her name and email.

\begingroup
\begin{gather*}
\pgfkeys{/pgf/inner sep=0pt} \pgfkeys{/pgf/inner xsep=0pt}
  \begin{forest}
    l sep=0,s sep=1em,
    for children={l sep=0,s sep=1em},
    [\bmth{\ell_{\text{Family}}} [\bmth{p_1}] [\bmth{\ell_{\text{Friends}}} [\bmth{p_2}] [\bmth{p_3}]]]
  \end{forest}
\end{gather*}
\endgroup

As play of the game progresses, Alice and Bob both make guesses, and a
driver calls the function \code{mark-hit} with each of their (faceted)
game boards. However, because Alice and Bob's game boards are both
facets, \code{mark-hit} cannot be immediately applied, as the argument
\code{board} is a facet. Faceted execution ``splits'' the execution of
the function on faceted arguments, running it first on the positive
branch, then again on the negative branch. Finally, the results of
each branch are merged to produce a facet:

%% \begin{center}
%%   \begin{tikzpicture}
%% 	  \node (0) at (0, 1) {\lstinline|(mark-hit |{\color{\colorMATH}\(\facet{\ell_A}{v^+}{v^-} ~~ x ~~y\)}\lstinline|)|};
%% 	  \node (1) at (2, 0)  {\lstinline|(mark-hit |{\color{\colorMATH}\(v^- ~~ x ~~ y\)}\lstinline|)|{\color{\colorMATH}\(~~= v''\)}};
%% 	  \node (2) at (-2, 0) {\lstinline|(mark-hit |{\color{\colorMATH}\(v^+ ~~ x ~~ y\)}\lstinline|)|{\color{\colorMATH}\(~~= v'\)}};
%% 	  \node (3) at (0, -1) {{\color{\colorMATH}\(\facet{\ell_A}{v'}{v''}\)}};
%% 	  \draw [->] (0) edge (1);
%% 	  \draw [->] (0) edge (2);
%% 	  \draw [->] (1) edge (3);
%% 	  \draw [->] (2) edge (3);
%%   \end{tikzpicture}
%% \end{center}

Because the applied function could be stateful, faceted execution also
records the current privilege level in a \emph{program counter}. The
program counter is used to build facets when writes are made to the
store inside of a privileged context. We expand upon these subtleties
in Section~\ref{sec:semantics}, where we present a full semantics for
faceted execution.

\kris{Stuff about obs here..}

\section{A Formal Semantics for Faceted Execution}

\begin{figure}
\begin{displaymath}
  \begin{array}{lcrcl}
    \blue{c} & \blue{\in} & \blue{const} & \blue{::=} & \blue{() \mid \code{\#t} \mid \code{\#f} \mid \ldots} \\
    \blue{x} & \blue{\in} & \blue{var} & \blue{::=} & \blue{\ldots}  \\
    \blue{e} & \blue{\in} & \blue{exp} & \blue{::=} & \blue{c} \mid \blue{x} \\
    & & & \blue{\mid} & \blue{(\lambda ~ (x) ~ e) \mid (e ~ e)} \\
    & & & \blue{\mid} & \blue{(\code{box} ~ e) \mid (\code{unbox} ~ e) \mid (\code{set!} ~ e ~ e)} \\
    & & & \blue{\mid} & \blue{(\code{let-label} ~ \ell ~ e ~ e)} \\
    & & & \blue{\mid} & \blue{(\code{facet} ~ e ~ e ~ e)} \\
    & & & \blue{\mid} & \blue{(\code{obs} ~ e ~ e ~ e)} \\
  \end{array}
\end{displaymath}
\label{fig:syntax}
\caption{Syntax of \lang}
\end{figure}

We now present a semantics for a core language (\lang) which includes
facets. Our presentation largely mirrors that of Austin et
al.~\cite{Austin:2013}. The syntax of our language---reminiscent of
Scheme---is shown in Figure~\ref{fig:syntax}. \lang extends the lambda
calculus with references (which have interact with facets in a subtle
way) and three forms unique to faceted execution: label creation,
facet construction, and facet observation.

\begin{figure*}
    \begin{tabular}{cc}
      \begin{minipage}{.5\textwidth}
        \begin{displaymath}
          \begin{array}{rcrcl}
            \blue{\alpha} & \blue{\in} & \blue{\text{addr}} & \blue{=} & \blue{\ldots} \\
            \blue{bv} & \blue{\in} & \blue{\text{base-val}} & \blue{::=} & \blue{c \mid \alpha \mid \langle \lambda x.~ e, \rho \rangle \mid \star}\\
            \fcol{v} & \blue{\in} & \blue{\text{faceted-val}} & \blue{::=} & \blue{bv \mid} ~ \fcol{\facet{\blue{\alpha}}{v}{v}}
            \\
          \end{array}
        \end{displaymath}
      \end{minipage}
      &
      \begin{minipage}{.5\textwidth}
        \begin{displaymath}
          \begin{array}{rcrcl}
            \fcol{b} & \fcol{\in} & \fcol{\text{branch}} & \fcol{::=} & \fcol{+ \ell \mid - \ell} \\
            \fcol{pc} & \fcol{\in} & \fcol{\text{PC}} & \fcol{=} & \fcol{\wp(\text{branch})} \\
            \blue{\rho} & \blue{\in} & \blue{\text{env}} & \blue{=} & \blue{\text{var} \rightharpoonup v}\\
            \blue{\sigma} & \blue{\in} & \blue{\text{store}} & \blue{=} & \blue{\text{addr} \rightharpoonup v}
            \\
          \end{array}
        \end{displaymath}
      \end{minipage}
    \end{tabular}
    \\
    \hfill \textit{(Expression Evaluation)} \boxed{\blue{e, \rho, \sigma \Downarrow_{pc}^E \sigma, v}}
    \\
    \begin{displaymath}
      \begin{array}{c}
        \begingroup
        \color{\colorMATH}
        \begin{array}{cccc}
          \inferrule[\textsc{Const}]{ }
                                    {c, \rho, \sigma \Downarrow_{pc}^E \sigma, c}
                    & 
          \inferrule[\textsc{Var}]{ }
                                  {x, \rho, \sigma \Downarrow_{pc}^E \sigma, \rho(x)}
                    & 
          \inferrule[\textsc{Lambda}]{ }
                                     {\lambda x. ~ e, \rho, \sigma \Downarrow_{pc}^E \sigma, \langle \lambda x. ~ e, \rho \rangle}
                    &
          \inferrule[\textsc{Apply}]{e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', v_1 \and
                                     e_2, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v_2 \\\\
                                     \fcol{(v_1 ~ v_2), \rho, \sigma'' \Downarrow_{pc}^A \sigma''', v'}}
                                    {(e_1 ~ e_2), \rho, \sigma \Downarrow_{pc}^E \sigma''', v'}
        \end{array}
       \endgroup
        \\\\
        \begingroup
        \color{\colorMATH}
        \begin{array}{ccc}
          \inferrule[\textsc{Box}]
                    {e, \rho, \sigma \Downarrow_{pc}^E \sigma', v \and
                      \alpha \not\in dom(\sigma') \\\\
                      \sigma'' = \sigma' [\alpha \mapsto \formfacet{pc}{v}{\star}]}
                    {(\code{box} ~ e), \rho, \sigma \Downarrow_{pc}^E \sigma'', \alpha}
                    & 
          \inferrule[\textsc{Unbox}]
                    {e, \rho, \sigma \Downarrow_{pc}^E \sigma', v \\\\
                     v' = \fcol{\var{read}(\sigma',v,pc)}}
                    {(\code{unbox} ~e), \rho, \sigma \Downarrow_{pc}^E \sigma', v'}
                    & 
          \inferrule[\textsc{Set}]
                    {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', v_1 \and
                     e_2, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v_2 \\\\
                     \sigma''' = \fcol{\var{write}(\sigma'', v_1, pc, v_2)}}
                    {(\code{set!} ~ e_1 ~ e_2), \rho, \sigma \Downarrow_{pc}^E \sigma''', v_2}
        \end{array}
       \endgroup
       \\\\
       \hfill \textit{(Facet Creation)}
       \\
       \begin{array}{ccc}
          {\color{\colorFAC}
          \inferrule[\textsc{Fac-Create-Split}]
          {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
            \{+\ell, -\ell\} \cap pc = \varnothing \\\\
           e_2, \rho, \sigma' \Downarrow_{pc \cup \{+l\}}^E \sigma'', v_1 \\\\
           e_3, \rho, \sigma'' \Downarrow_{pc \cup \{-l\}}^E \sigma''', v_2 \and
           v = \formfacet{pc}{v_1}{v_2}}
          {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma''', v}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{Fac-Create-Pos}]
          {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
           + \ell \in pc \\\\
           e_2, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v}
          {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'', v}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{Fac-Create-Neg}]
          {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
           - \ell \in pc \\\\
           e_3, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v}
          {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'', v}}     \end{array}

      \end{array}
    \end{displaymath}
    \\
    \hfill \textit{(Label Creation / Observation)}
    \\
    \[
    \begin{array}{cc}
      {\color{\colorFAC}
        \inferrule[\textsc{Let-Label}]
          {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \langle \lambda x. ~ e, \rho' \rangle \\\\
           \alpha \not\in dom(\sigma') \and \sigma'' = \sigma' [\alpha \mapsto \langle \lambda x. ~ e, \rho' \rangle] \\\\
           e_2, \rho [ \ell \mapsto \alpha ], \sigma'' \Downarrow_{pc}^E \sigma''', v}
          {(\code{let-label} ~ \ell ~ e_1 ~ e_2), \rho, \sigma \Downarrow_{pc}^E \sigma''', v}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{Obs}]
                    {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell
                      \and e_2, \rho, \sigma' \Downarrow_{pc}^E \sigma'', v  \\\\
                      \langle (\lambda x.~e), \rho' \rangle = \sigma''(\ell) \\\\
                      e, \rho' [x \mapsto v], \sigma'' \Downarrow_{pc}^E \sigma''', v^{\pm} \\\\
                      e_3, \rho, \sigma''' \Downarrow_{pc}^E \sigma'''', v' \\\\
                      v'' = \fcol{\var{obs}(\ell, v', v^{\pm})}}
                    {(\code{obs} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'''', v''}}
    \end{array}
    \]
    \\
    \hfill \textit{(Possibly-Faceted Application)} \boxed{\fcol{(v_1 ~ v_2), \rho, \sigma \Downarrow_{pc}^A \sigma, v}}
    \\
    \begingroup
    \color{\colorMATH}
    \begin{displaymath}
      \begin{array}{c}
        \begin{array}{ccc}
          {\color{\colorMATH}
          \inferrule[\textsc{App-$\star$}]
          { }
          {(\star ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma, \star}}
          & 
          {\color{\colorMATH}
          \inferrule[\textsc{App-Base}]
          {e, \rho'[x \mapsto v], \sigma \Downarrow_{pc}^E \sigma', v' }
          {(\langle \lambda x.~e, \rho' \rangle ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{App-Split}]
          {\{+\ell, -\ell\} \cap pc = \varnothing \and
            (v^+ ~ v), \rho, \sigma \Downarrow_{pc \cup \{+\ell\}}^A \sigma', {v^+}' \\\\
            (v^- ~ v), \rho, \sigma' \Downarrow_{pc \cup \{-\ell\}}^A \sigma'', {v^-}' \and
            v' = \formfacet{\{+ \ell\}}{{v^+}'}{{v^-}'}}
          {(\facet{\ell}{v^+}{v^-} ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma'', v'}}
        \end{array}
        \\
        \begin{array}{cc}
        \\\\
          {\color{\colorFAC}
          \inferrule[\textsc{App-Facet-Pos}]
          {+\ell \in pc \\\\
            (v^+ ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}
          {(\facet{\ell}{v^+}{v^-} ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}}
          & 
          {\color{\colorFAC}
          \inferrule[\textsc{App-Facet-Neg}]
          {-\ell \in pc \\\\
            (v^- ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}
          {(\facet{\ell}{v^+}{v^-} ~ v), \rho, \sigma \Downarrow_{pc}^A \sigma', v'}}
        \end{array}
      \end{array}
    \end{displaymath}
    \endgroup
    \label{fig:semantics}
\end{figure*}

\begin{figure*}
  \hfill \textit{(Metafunctions)}
      \\
      \begin{displaymath}
        \begin{array}{rclrr}
          {read(\sigma, \alpha, pc)} & {=} & {\sigma(\alpha)} & & \\
          {read(\sigma, \facet{\ell}{v_1}{v_2}), pc} & = & {read(\sigma, v_1, pc)} & \textit{if} ~ {+\ell} \in pc & \\
          {read(\sigma, \facet{\ell}{v_1}{v_2}), pc} & = & {read(\sigma, v_2, pc)} & \textit{if} ~ {-\ell} \in pc & \\
          {read(\sigma, \facet{\ell}{v_1}{v_2}), pc} & = & {\formfacet{\ell}{read(\sigma, v_1, pc)}{read(\sigma, v_2, pc)}} & \textit{otherwise} &
        \end{array}
      \end{displaymath}
      \\
      \begin{displaymath}
        \begin{array}{rclrr}
          {write(\sigma, \alpha, pc, v)} & {=} & {\sigma[\alpha ~ := \formfacet{pc}{v}{\sigma(\alpha)}]} & & \\
          {write(\sigma, \facet{\ell}{v_1}{v_2}), pc, v} & = & {\sigma''} & \textit{where} ~ {\sigma' = write(\sigma, v_1, pc \cup \{+\ell\}, v)} \\
          & & & \textit{and} ~ {\sigma'' = write(\sigma', v_2, pc \cup \{-\ell\}, v)}
        \end{array}
      \end{displaymath}
      \\
      \begin{displaymath}
        \begin{array}{rclrr}
          {obs(\ell, b, bv)} & {=} & {bv} & & \\
          {obs(\ell, true,} \facet{\ell}{v_1}{v_2}) & = & {v_1} & & \\
          {obs(\ell, false,} \facet{\ell}{v_1}{v_2}) & = & {v_2} & & \\
          {obs(\ell, b,} \facet{\ell'}{v_1}{v_2}) & = & \facet{\ell'}{obs(\ell,b,v_1)}{obs(\ell,b,v_2)} & \textit{where} & {\ell} \neq {\ell'}
        \end{array}
      \end{displaymath}
\end{figure*}

\section{Faceted Execution as Macros}

The semantics of faceted execution is an extension of the lambda
calculus, leading to a natural question: can we use Racket's macros to
extend Racket to faceted execution? We will see that the answer is
yes, and the translation from the big-step rules is surprisingly
straightforward. This section of our paper describes the design of
Racets, a prototype implementation of faceted execution using Racket
macros. In Section~\ref{sec:conclusion} we remark upon current
directions scaling Racets to the whole of Racket.

\paragraph*{Choosing a Representation for Facets, Labels, and Program Counters}

In setting out to implement facets, we must first choose how we will
represent facets, labels, and program counters. We have chosen to
implement facets simply as Racket \lstinline|struct|s, containing a
label along with positive and negative branches:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(struct facet (labelname left right))
\end{lstlisting}

Next, we must choose a representation of labels. At first
consideration, it appears sensible to represent labels simply as
closures. After all, labels are simply used as predicates testing
whether or not to reveal a facet's positive or negative
branch. However, there is a subtle issue: facet canonicalization
relies upon a total order for labels. In light of this, we represent
labels as a pair of a name and a policy:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(struct labelpair (name pol))
\end{lstlisting}

Now that we have defined labels, we can define branches, which are
positive or negative labels:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(struct pos (lab))
(struct neg (lab))
\end{lstlisting}

Similarly, program counters are sets of branches. However, we must
still ask how we will keep track of the ``current'' program
counter. Our implementation uses Racket's parameters, though other
mechanisms (such as continuation marks\kris{cite}, to which parameters
macro-expand) could also be used. Racets defines the parameter
\code{current-pc}, and updates it as computation progresses:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(define current-pc (make-parameter (set)))
\end{lstlisting}

\paragraph*{Facet Creation}

Facet creation appears as three separate rules in
Figure~\ref{fig:semantics}, which we recapitulate here in three
distint colors for each case:

\[
\begin{array}{ccc}
  {\color{brown}
    \inferrule[\textsc{Fac-Create-Left}]
              {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
                \boxed{+ \ell \in pc} \\\\
                e_2, \rho, \sigma \Downarrow_{pc}^E \sigma'', v}
              {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'', v}}
  & 
  {\color{gray}
    \inferrule[\textsc{Fac-Create-Right}]
              {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
                \boxed{- \ell \in pc} \\\\
                e_3, \rho, \sigma \Downarrow_{pc}^E \sigma'', v}
              {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma'', v}}
  &
  {\color{purple}
    \inferrule[\textsc{Fac-Create-Split}]
              {e_1, \rho, \sigma \Downarrow_{pc}^E \sigma', \ell \and
                \boxed{\{+\ell, -\ell\} \cup pc = \varnothing} \\\\
                e_2, \rho, \sigma' \Downarrow_{pc \cup \{+l\}}^E \sigma'', v_1 \\\\
                e_3, \rho, \sigma'' \Downarrow_{pc \cup \{-l\}}^E \sigma''', v_2 \and
                v = \formfacet{pc}{v_1}{v_2}}
              {(\code{fac} ~ e_1 ~ e_2 ~ e_3), \rho, \sigma \Downarrow_{pc}^E \sigma''', v}}


\end{array}
\]

Translating these rules to Racket involves observing that each of
these rules will apply under one of three disjoint circumstances (each
of them boxed in the above rules): $+\ell \in pc$, $-\ell \in pc$, or
else $\{+\ell,-\ell\} \cap pc = \varnothing$. This leads to a
relatively straightforward implementation that inspects the current
program counter to decide which rule to implement:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(define-syntax-rule (fac l e1 e2)
  (cond
|{\color{brown}|    [(set-member? (current-pc) (pos (facet-labelname l))) e1] |}|
|{\color{gray}|    [(set-member? (current-pc) (neg (facet-labelname l))) e2]  |}|

|{\color{purple}|    [else
     (let ([left
            (parameterize ([current-pc (set-add (current-pc)
                                                (pos (facet-labelname l)))]))]
           [right
            (parameterize ([current-pc (set-add (current-pc)
                                                (neg (facet-labelname l)))]))]
           (mkfacet (labelpair-name l) v1 v2)))])) |}|
\end{lstlisting}


As our definition is a transliteration of that in Figure 6 of Austin
et. al's paper~\cite{Austin:2012}, we omit the implementation here.
The result is a function, \code{mkfacet}, which (given a label and
both positive and negative branches) forms a facet:

\begin{lstlisting}[language=Racket,escapechar=|,name=racets]
(define (mkfacet label v1 v2)
  (canonicalize (set-add (current-pc) (pos name)) v1 v2))
\end{lstlisting}


\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}

\end{document}
